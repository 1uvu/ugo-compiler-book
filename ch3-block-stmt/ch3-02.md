# 3.2 AST到LLVM汇编

在前一节我们已经采用AST形式编写了一个最小µGo程序，本节我们尝试将这个AST翻译到LLVM汇编程序。

## 3.2.1 对应的LLVM汇编程序

我们已经了解了AST的数据结构，在翻以前我们还需要明确要输出的汇编代码的形式。只有先在大脑人肉完成翻译工作后，才真正好通过程序实现自动化的翻译。

结合第二章表达式的内容，可以想象输出以下的汇编程序：

```ll
declare i32 @ugo_builtin_exit(i32)

define i32 @ugo_main_main() {
	%t0 = add i32 0, 40    ; t0 = 40
	%t1 = add i32 0, 2     ; t1 = 2
	%t2 = add i32 %t0, %t1 ; t2 = t1 + t1
	call i32(i32) @ugo_builtin_exit(i32 %t2)
	ret i32 0
}
```

第一句是通过declare声明`@ugo_builtin_exit`内置函数（稍后通过其他工具生成），其作用是将一个整数参数作为退出码退出程序。然后`@ugo_main_main`是µGo的main包中的main函数输出的LLVM对应的函数，并在开头增加了`ugo_`前缀。函数体则是通过计算一个表达式，然后作为参数调用µGo的exit内置函数对应的代码。

要执行该程序需要在main入口函数调用`@ugo_main_main`函数：

```ll
define i32 @main() {
	call i32() @ugo_main_main()
	ret i32 0
}
```

以上这2段代码就是我们的编译器需要生成的汇编程序。

## 3.2.2 准备`@ugo.builtin.exit`内置函数

为了简单，我们采用C语言实现µGo内置的`@ugo_builtin_exit`函数：

```c
// builtin.c
extern int exit(int);

int ugo_builtin_exit(int x) {
	exit(x);
	return 0;
}
```

然后用`clang -S -emit-llvm builtin.c`将C代码转化为LLVM汇编语言格式。输出的`builtin.ll`文件如下：

```ll
declare i32 @exit(i32)

define i32 @ugo_builtin_exit(i32) {
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = load i32, i32* %2, align 4
  %4 = call i32 @exit(i32 %3)
  unreachable
}
```

然后结合前面编译器将要生成的`main.ll`程序，用clang命令再编译连接执行：

```
$ clang builtin.ll main.ll
$ ./a.out
$ echo $?
42
```

验证一切正常之后，我们就可以开始尝试用程序生成`main.ll`了。

## 3.2.3 构造`compiler.Compiler`对象



