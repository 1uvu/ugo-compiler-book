# 3.3 完善词法解析器

以最小µGo程序为例，本节讨论如何继续完善词法解析器，为后续的语法解析器提供基础。

## 3.3.1 Token视角的µGo程序

英语和中文有着极大的区别：英语由少量的26个字母构成，然后由字母再构造成一个个单词，而这些单词和中文的一个个汉字类似，每个单词都有着一定的语义。词法分析的工作和英语中从字母序列分析为单词序列的工作类似（中文应为汉字数量众多，词法解析的比重相对较低）。我们看到的程序其实都是字母序列，因此第一步工作是将字母序列转换为单词序列。

而µGo编译器中每个单词对应属于Token，一个Token可以是一个数字、也可以是一个变量名，或则是一个加法符号。我们现在以Token视角看看之前的µGo程序是什么样子的。

最小µGo程序的字母序列（为了不被语法高亮的特性迷惑，这里刻意关闭了语法高亮特性）：

```txt
package main

func main() {
	exit(40+2) // 退出码 42
}
```

对应的Token序列如下（忽略注释部分）：

```go
import "github.com/chai2010/ugo/token"

var ugoTokens = []token.Token {
	{Type: token.PACKAGE},              // package
	{Type: token.IDENT, Value: "main"}, // main
	{Type: token.FUNC},                 // func
	{Type: token.IDENT, Value: "main"}, // main
	{Type: token.LPAREN},               // (
	{Type: token.RPAREN},               // )
	{Type: token.LBRACE},               // {
	{Type: token.IDENT, Value: "exit"}, // exit
	{Type: token.LPAREN},               // (
	{Type: token.NUMBER, Value: 40},    // 40
	{Type: token.ADD},                  // +
	{Type: token.NUMBER, Value: 2},     // 2
	{Type: token.RPAREN},               // )
	{Type: token.RBRACE},               // }
}
```

这种转化也就是此法解析器需要完成的工作：我们需要在能够尽量准确表达原始程序的前提下尽量简化后续解析器的分析工作。目前看，这个词法序列似乎是可以准确表示最小µGo程序的。

## 3.3.2 分号和注释

我们尝试再从Token序列反向恢复出原始的µGo程序：

```go
package main func main() { exit(40+2) }
```

实际上这是个错误的Go程序，将会产生以下的语法错误：

```
syntax error: unexpected func, expecting semicolon or newline
```

简单说，在`package main`和`func`之间至少要有一个换行符号或则是分号。其实语法解析器最终需要的是分号，因为分号才是Go语言中语句的分隔符号（正如空白也是单词之间的分隔符）。而Go语言的词法解析起在解析时如果是特殊的Token遇到换行（标识符、数字或字符串等字面值、break/continue/fallthrough/return等关键字、`++`/`--`/`)`/`]`/`}`等运算符，同时`)`/`}`之前的分号可以省略，具体请参考 [spec](https://golang.google.cn/ref/spec#Semicolons) 文档），会自动添加分号。

同样，注释是可以以任意的形式混入在Token序列之间的。如果加入注释的干扰，会导致语法的定义和分析变得复杂。常见的做法是词法解析的同时记录每个Token的位置信息，词法解析完成后将注释剥离再进行语法解析，等语法解析器完成AST构造之后再将注释根据位置合并到AST的相应结点中。

## 3.3.3 完善token包的记号类型

token包的内容和第2章结构类似，增加了部分新的关键字类型：

```go
package token

// 记号类型
type TokenType int

// ch3中 µGo程序用到的记号类型
const (
	EOF TokenType = iota
	ERROR

	IDENT
	NUMBER

	PACKAGE
	FUNC

	ADD // +
	SUB // -
	MUL // *
	DIV // /

	LPAREN // (
	RPAREN // )
	LBRACE // {
	RBRACE // }

	SEMICOLON // ;
)
```

增加了IDENT表示标识符、PACKAGE定义包、FUNC针对函数大括弧用于定义函数的Body、并引入了分号。如果是语法位置记号用ERROR表示，EOF表示文件结束。

token.Token对应记号的值（含记号类型、解析后的值、位置和原始面值）：

```go
type Token struct {
	Type    TokenType   // 记号的类型
	Value   interface{} // 记号的值, 目前只有 int
	Pos     int         // 记号所在的位置(从1开始)
	Literal string      // 程序中原始的字符串
}
```

这样我们就可以用`[]token.Token`表示的记号序列来等价地表示词法解析后的代码。

### 3.3.4 重构词法解析器

在地2章最后的例子中，我们通过包装`text/scanner`标准库实现了词法解析。这种方式虽然可以用于µGo程序，但是依然有隔山打牛的弊端。本节我们该用纯手工的方式重新实现词法解析，这样不仅仅可以让我们可以了解词法解析的实现细节，而且词法解析的套路依然可以用于后续的AST解析工作。这种问题只要彻底解决一次就一劳永逸了。

#### 3.3.4.1 字节流的Reader

词法解析的输入是字节流，在解析的过程中常常需要向前多看一个字符，同时也可能要忽略一些字符，为此我们需要先构造一个字节流的Reader（这个设计同样可以复制到Token流Reader，用于语法解析）。

TODO

<!--
词法流读接口
-->
