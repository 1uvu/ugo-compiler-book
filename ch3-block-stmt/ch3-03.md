# 3.3 完善词法解析器

以最小µGo程序为例，本节讨论如何继续完善词法解析器，为后续的语法解析器提供基础。

## 3.3.1 Token视角的µGo程序

英语和中文有着极大的区别：英语由少量的26个字母构成，然后由字母再构造成一个个单词，而这些单词和中文的一个个汉字类似，每个单词都有着一定的语义。词法分析的工作和英语中从字母序列分析为单词序列的工作类似（中文应为汉字数量众多，词法解析的比重相对较低）。我们看到的程序其实都是字母序列，因此第一步工作是将字母序列转换为单词序列。

而µGo编译器中每个单词对应属于Token，一个Token可以是一个数字、也可以是一个变量名，或则是一个加法符号。我们现在以Token视角看看之前的µGo程序是什么样子的。

最小µGo程序的字母序列（为了不被语法高亮的特性迷惑，这里刻意关闭了语法高亮特性）：

```txt
package main

func main() {
	exit(40+2) // 退出码 42
}
```

对应的Token序列如下（忽略注释部分）：

```go
import "github.com/chai2010/ugo/token"

var ugoTokens = []token.Token {
	{Type: token.PACKAGE},              // package
	{Type: token.IDENT, Value: "main"}, // main
	{Type: token.FUNC},                 // func
	{Type: token.IDENT, Value: "main"}, // main
	{Type: token.LPAREN},               // (
	{Type: token.RPAREN},               // )
	{Type: token.LBRACE},               // {
	{Type: token.IDENT, Value: "exit"}, // exit
	{Type: token.LPAREN},               // (
	{Type: token.NUMBER, Value: 40},    // 40
	{Type: token.ADD},                  // +
	{Type: token.NUMBER, Value: 2},     // 2
	{Type: token.RPAREN},               // )
	{Type: token.RBRACE},               // }
}
```

这种转化也就是此法解析器需要完成的工作：我们需要在能够尽量准确表达原始程序的前提下尽量简化后续解析器的分析工作。目前看，这个词法序列似乎是可以准确表示最小µGo程序的。

## 3.3.2 分号和注释

我们尝试再从Token序列反向恢复出原始的µGo程序：

```go
package main func main() { exit(40+2) }
```

实际上这是个错误的Go程序，将会产生以下的语法错误：

```
syntax error: unexpected func, expecting semicolon or newline
```

简单说，在`package main`和`func`之间至少要有一个换行符号或则是分号。其实语法解析器最终需要的是分号，因为分号才是Go语言中语句的分隔符号（正如空白也是单词之间的分隔符）。而Go语言的词法解析起在解析时如果是特殊的Token遇到换行（标识符、数字或字符串等字面值、break/continue/fallthrough/return等关键字、`++`/`--`/`)`/`]`/`}`等运算符，同时`)`/`}`之前的分号可以省略，具体请参考 https://golang.google.cn/ref/spec#Semicolons ），会自动添加分号。

同样，注释是可以以任意的形式混入在Token序列之间的。如果加入注释的干扰，会导致语法的定义和分析变得复杂。常见的做法是词法解析的同时记录每个Token的位置信息，词法解析完成后将注释剥离再进行语法解析，等语法解析器完成AST构造之后再将注释根据位置合并到AST的相应结点中。

## 3.3.3 完整的token包

TODO

<!--
词法流读接口
-->
