# 3.5 打印AST语法树

我们已经实现了µGo程序的语法树解析，为了方便调试我们经常需要打印语法树。本节将为语法树实现格式化打印支持。

## 3.5.1 打印JSON

最简单的打印AST方式是输出JSON格式，为`ast.File`增加`JSONString`方法如下：

```go
package ast

func (p *File) JSONString() string {
	file := *p
	if len(file.Source) > 8 {
		file.Source = file.Source[:8] + "..."
	}
	d, _ := json.MarshalIndent(&file, "", "    ")
	return string(d)
}
```

为了减少`ast.File.Source`的干扰，当µGo源代码较长时用省略号表示。然后通过json.MarshalIndent打印缩进格式的JSON。

构造测试函数：

```go
func main() {
	code := loadCode("../hello.ugo")
	f, err := parser.ParseFile("../hello.ugo", code)
	if err != nil {
		panic(err)
	}

	fmt.Println(f.JSONString())
}

func loadCode(filename string) string {
	data, err := os.ReadFile(filename)
	if err != nil {
		panic(err)
	}
	return string(data)
}
```

输入JSON如下：

```json
{
    "Filename": "../hello.ugo",
    "Source": "package ...",
    "Pkg": {
        "PkgPos": 1,
        "NamePos": 9,
        "Name": "main"
    },
    "Funcs": [
        {
            "FuncPos": 15,
            "NamePos": 20,
            "Name": "main",
            "Body": {
                "Lbrace": 27,
                "List": [
                    {
                        "X": {
                            "FuncName": "exit",
                            "Lparen": 34,
                            "Args": [
                                {
                                    "OpPos": 38,
                                    "Op": 7,
                                    "X": {
                                        "ValuePos": 35,
                                        "ValueEnd": 37,
                                        "Value": 40
                                    },
                                    "Y": {
                                        "ValuePos": 40,
                                        "ValueEnd": 41,
                                        "Value": 2
                                    }
                                }
                            ],
                            "Rparen": 41
                        }
                    }
                ],
                "Rbrace": 59
            }
        }
    ]
}
```

JSON数据忠实地反映了AST中的数据。但是JSON丢失了AST成员的类型信息，同时Pos显示为数字不够直观。因此JSON更适合程序之间交换数据，对于调试AST需求JSON依然不够直观。

## 3.5.2 打印 Pos

为了更好地展示 Pos 信息，我们新定义 `token.Pos` 类型：

```go
package token

// Pos 类似一个指针, 表示文件中的位置.
type Pos int

// NoPos 类似指针的 nil 值, 表示一个无效的位置.
const NoPos Pos = 0

func (p Pos) IsValid() bool { return p != NoPos }
```

Pos 是基于 int 类型定义的新类型，类似一种抽象的指针，用于表示文件中的位置偏移量。其中 NoPos 对应 0 表示一个无效的地址（类似一个nil指针），因此有效的 Pos 是从1开始的。

同时增加一个 Position 表示基于行列号的位置信息：

```go
type Position struct {
	Filename string // 文件名
	Offset   int    // 偏移量, 从 0 开始
	Line     int    // 行号, 从 1 开始
	Column   int    // 列号, 从 1 开始
}
```

结合源代码可以将Pos转换行列号的Position结构：

```go
func (pos Pos) Position(filename, src string) Position {
	var p = Position{
		Filename: filename,
		Offset:   int(pos) - 1,
		Line:     1,
		Column:   1,
	}

	for _, c := range []byte(src[:p.Offset]) {
		p.Column++
		if c == '\n' {
			p.Column = 1
			p.Line++
		}
	}

	return p
}
```

Position结果有自己的String方法：

```go
func (pos Position) String() string {
	s := pos.Filename
	if pos.IsValid() {
		if s != "" {
			s += ":"
		}
		s += fmt.Sprintf("%d", pos.Line)
		if pos.Column != 0 {
			s += fmt.Sprintf(":%d", pos.Column)
		}
	}
	if s == "" {
		s = "-"
	}
	return s
}
```

对应以下几种输出格式：

```go
//	file:line:column    valid position with file name
//	file:line           valid position with file name but no column (column == 0)
//	line:column         valid position without file name
//	line                valid position without file name and no column (column == 0)
//	file                invalid position with file name
//	-                   invalid position without file name
```

在VSCode等环境中，可以根据`file:line:column`格式的位置直接跳转到对应的位置，这样可以极大提高调试的效率。

## 3.5.3 改造AST

首先改造AST结构，将其中的`token.Token`类型改造为`token.TokenType`和`token.Pos`表示。目前只有一元和二元表达式需要改造：

```go
type BinaryExpr struct {
	Op token.Token // 运算符
	X  Expr        // 左边的运算对象
	Y  Expr        // 右边的运算对象
}

type UnaryExpr struct {
	Op token.Token // 运算符
	X  Expr        // 运算对象
}
```

改造后如下：

```go
type BinaryExpr struct {
	OpPos token.Pos       // 运算符位置
	Op    token.TokenType // 运算符类型
	X     Expr            // 左边的运算对象
	Y     Expr            // 右边的运算对象
}

// UnaryExpr 表示一个一元表达式.
type UnaryExpr struct {
	OpPos token.Pos       // 运算符位置
	Op    token.TokenType // 运算符类型
	X     Expr            // 运算对象
}
```

其次将之前用int类型表示的Pos成员改造为`token.Pos`类型。这类需要改造的地方比较多，但是改造的工作是类似的。比如表示数字面值的Number改造后如下：

```go
type Number struct {
	ValuePos token.Pos
	ValueEnd token.Pos
	Value    int
}
```

此外为了方便跟踪函数名和变量名等标识符，我们新增加了`ast.Ident`结构：

```go
type Ident struct {
	NamePos token.Pos
	Name    string
}
```

函数调用`ast.CallExpr`中的`FuncName`成员就可以用`ast.Ident`指针表示了：

```go
type CallExpr struct {
	FuncName *Ident    // 函数名字
	Lparen   token.Pos // '(' 位置
	Args     []Expr    // 调用参数列表
	Rparen   token.Pos // ')' 位置
}
```

AST结构发生变化后，parser包也需要做相应的更新，这类不再详细展开。

## 3.5.4 AST打印

TODO
