# 5.3 if和for到LLIR汇编

赋值重构：

```go
func (p *Compiler) compileStmt(w io.Writer, stmt ast.Stmt) {
	switch stmt := stmt.(type) {
	...
	case *ast.AssignStmt:
		p.compileStmt_assign(w, stmt)
	...
	}
}
```

```go
func (p *Compiler) compileStmt_assign(w io.Writer, stmt *ast.AssignStmt) {
	...
	if stmt.Op == token.DEFINE {
		...
	}
	...
}
```

Scope 恢复：

```go
func (p *Compiler) restoreScope(scope *Scope) {
	p.scope = scope
}
```

```go
	defer p.restoreScope(p.scope)
	p.enterScope()
```

运算符：

```go
func (p *Compiler) compileExpr(w io.Writer, expr ast.Expr) (localName string) {
	switch expr := expr.(type) {
	...
	case *ast.BinaryExpr:
		localName = p.genId()
		switch expr.Op {
		case token.MOD:
			fmt.Fprintf(w, "\t%s = %s i32 %v, %v\n",
				localName, "srem", p.compileExpr(w, expr.X), p.compileExpr(w, expr.Y),
			)
			return localName

		// https://llvm.org/docs/LangRef.html#icmp-instruction

		case token.EQL: // ==
			fmt.Fprintf(w, "\t%s = %s i32 %v, %v\n",
				localName, "icmp eq", p.compileExpr(w, expr.X), p.compileExpr(w, expr.Y),
			)
			return localName
		case token.NEQ: // !=
			fmt.Fprintf(w, "\t%s = %s i32 %v, %v\n",
				localName, "icmp ne", p.compileExpr(w, expr.X), p.compileExpr(w, expr.Y),
			)
			return localName
		case token.LSS: // <
			fmt.Fprintf(w, "\t%s = %s i32 %v, %v\n",
				localName, "icmp slt", p.compileExpr(w, expr.X), p.compileExpr(w, expr.Y),
			)
			return localName
		case token.LEQ: // <=
			fmt.Fprintf(w, "\t%s = %s i32 %v, %v\n",
				localName, "icmp sle", p.compileExpr(w, expr.X), p.compileExpr(w, expr.Y),
			)
			return localName
		case token.GTR: // >
			fmt.Fprintf(w, "\t%s = %s i32 %v, %v\n",
				localName, "icmp sgt", p.compileExpr(w, expr.X), p.compileExpr(w, expr.Y),
			)
			return localName
		case token.GEQ: // >=
			fmt.Fprintf(w, "\t%s = %s i32 %v, %v\n",
				localName, "icmp sge", p.compileExpr(w, expr.X), p.compileExpr(w, expr.Y),
			)
			return localName
		}
		...
	}
}
```

```go
func (p *Compiler) compileStmt(w io.Writer, stmt ast.Stmt) {
	switch stmt := stmt.(type) {
	...
	case *ast.IfStmt:
		p.compileStmt_if(w, stmt)

	case *ast.ForStmt:
		p.compileStmt_for(w, stmt)
	...
	}
}
```

```go
func (p *Compiler) compileStmt_if(w io.Writer, stmt *ast.IfStmt) {
	defer p.restoreScope(p.scope)
	p.enterScope()

	ifPos := fmt.Sprintf("%d", p.posLine(stmt.If))
	ifInit := p.genLabelId("if.init.line" + ifPos)
	ifCond := p.genLabelId("if.cond.line" + ifPos)
	ifBody := p.genLabelId("if.body.line" + ifPos)
	ifElse := p.genLabelId("if.else.line" + ifPos)
	ifEnd := p.genLabelId("if.end.line" + ifPos)

	// br if.init
	fmt.Fprintf(w, "\tbr label %%%s\n", ifInit)

	// if.init
	fmt.Fprintf(w, "\n%s:\n", ifInit)
	func() {
		defer p.restoreScope(p.scope)
		p.enterScope()

		if stmt.Init != nil {
			p.compileStmt(w, stmt.Init)
			fmt.Fprintf(w, "\tbr label %%%s\n", ifCond)
		} else {
			fmt.Fprintf(w, "\tbr label %%%s\n", ifCond)
		}

		// if.cond
		{
			fmt.Fprintf(w, "\n%s:\n", ifCond)
			condValue := p.compileExpr(w, stmt.Cond)
			fmt.Fprintf(w, "\tbr i1 %s , label %%%s, label %%%s\n", condValue, ifBody, ifEnd)
		}

		// if.body
		func() {
			defer p.restoreScope(p.scope)
			p.enterScope()

			fmt.Fprintf(w, "\n%s:\n", ifBody)
			p.compileStmt(w, stmt.Body)
			fmt.Fprintf(w, "\tbr label %%%s\n", ifEnd)
		}()

		// if.else
		func() {
			defer p.restoreScope(p.scope)
			p.enterScope()

			fmt.Fprintf(w, "\n%s:\n", ifElse)
			fmt.Fprintf(w, "\tbr label %%%s\n", ifEnd)
		}()
	}()

	// end
	fmt.Fprintf(w, "\n%s:\n", ifEnd)
}
```

```go
func (p *Compiler) compileStmt_for(w io.Writer, stmt *ast.ForStmt) {
	defer p.restoreScope(p.scope)
	p.enterScope()

	forPos := fmt.Sprintf("%d", p.posLine(stmt.For))
	forInit := p.genLabelId("for.init.line" + forPos)
	forCond := p.genLabelId("for.cond.line" + forPos)
	forPost := p.genLabelId("for.post.line" + forPos)
	forBody := p.genLabelId("for.body.line" + forPos)
	forEnd := p.genLabelId("for.end.line" + forPos)

	// br for.init
	fmt.Fprintf(w, "\tbr label %%%s\n", forInit)

	// for.init
	func() {
		defer p.restoreScope(p.scope)
		p.enterScope()

		fmt.Fprintf(w, "\n%s:\n", forInit)
		if stmt.Init != nil {
			p.compileStmt(w, stmt.Init)
			fmt.Fprintf(w, "\tbr label %%%s\n", forCond)
		} else {
			fmt.Fprintf(w, "\tbr label %%%s\n", forCond)
		}

		// for.cond
		fmt.Fprintf(w, "\n%s:\n", forCond)
		if stmt.Cond != nil {
			condValue := p.compileExpr(w, stmt.Cond)
			fmt.Fprintf(w, "\tbr i1 %s , label %%%s, label %%%s\n", condValue, forBody, forEnd)
		} else {
			fmt.Fprintf(w, "\tbr label %%%s\n", forBody)
		}

		// for.body
		func() {
			defer p.restoreScope(p.scope)
			p.enterScope()

			fmt.Fprintf(w, "\n%s:\n", forBody)
			p.compileStmt(w, stmt.Body)
			fmt.Fprintf(w, "\tbr label %%%s\n", forPost)
		}()

		// for.post
		{
			fmt.Fprintf(w, "\n%s:\n", forPost)
			if stmt.Post != nil {
				p.compileStmt(w, stmt.Post)
				fmt.Fprintf(w, "\tbr label %%%s\n", forCond)
			} else {
				fmt.Fprintf(w, "\tbr label %%%s\n", forCond)
			}
		}
	}()

	// end
	fmt.Fprintf(w, "\n%s:\n", forEnd)
}
```
